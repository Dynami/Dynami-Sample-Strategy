/*
 * Copyright 2015 Alessandro Atria - a.atria@gmail.com
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.sample.strategy;

import org.dynami.core.Event;
import org.dynami.core.Event.Type;
import org.dynami.core.IDynami;
import org.dynami.core.IStage;
import org.dynami.core.orders.MarketOrder;
import org.dynami.core.orders.cond.StopLoss;

public class OpenGapExploiter implements IStage {

	// WORK IN PROGRESS -
	// THIS IS NOT AN ADVICE FOR INVESTMENT.
	// PLEASE, READ DISCLAIMER IN DYNAMI PROJECT BLOG
	private final int BARS_TO_COVER = 120;
	private final int SKIP_BARS = 5;
	private double lastHigh = 0, lastLow = Double.MAX_VALUE;
	private double previousHigh = 0, previousLow = 0, previousClose = 0;
	private boolean isUpperGap, isLowerGap;
	private int barCounter = 0;


	@Override
	public void setup(IDynami dynami) {

	}

	@Override
	public void process(IDynami dynami, Event event) {
		if(event.is(Type.OnBarClose)){
			lastHigh = Math.max(lastHigh, event.bar.high);
			lastLow = Math.min(lastLow, event.bar.low);

			barCounter++;

			if(isUpperGap){
				if(event.bar.low <= previousHigh && barCounter >= SKIP_BARS && barCounter <= BARS_TO_COVER){
					isUpperGap = false;
					dynami.orders().send(new MarketOrder(event.symbol, 1, "Go long on covered gap").add(new StopLoss(previousClose)));
				}
				if(barCounter > BARS_TO_COVER){
					isUpperGap = false;
					//dynami.orders().send(new MarketOrder(event.symbol, 1, "Go long on uncovered gap").add(new StopLoss(previousClose)));
				}
			}

			if(isLowerGap){
				if(event.bar.high >= previousLow && barCounter >= SKIP_BARS && barCounter <= BARS_TO_COVER){
					isLowerGap = false;
					dynami.orders().send(new MarketOrder(event.symbol, -1, "Go short on covered gap").add(new StopLoss(previousClose)));
				}
				if(barCounter > BARS_TO_COVER){
					isLowerGap = false;
					//dynami.orders().send(new MarketOrder(event.symbol, -1, "Go Short on uncovered gap").add(new StopLoss(previousClose)));
				}
			}
		}

		if(event.is(Type.OnDayClose)){
			// close all positions
			SampleStrategy.closeAll(dynami);

			// set previous data
			previousHigh = lastHigh;
			previousLow = lastLow;
			previousClose = event.bar.close;
			// reset daily settings
			lastHigh = 0;
			lastLow = Double.MAX_VALUE;
			isUpperGap = false;
			isLowerGap = false;
			barCounter = 0;
		}

		if(event.is(Type.OnDayOpen)){
			// check gap on previous high price
			if(previousHigh > 0 && event.bar.low > previousHigh){
				isUpperGap = true;
			}

			// check gap on previous low price
			if(previousLow > 0 && event.bar.high < previousLow){
				isLowerGap = true;
			}
		}
	}
}
